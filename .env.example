# Fast-Flow Orchestrator - Environment Variables Example
# Kopiere diese Datei zu .env und passe die Werte an

# Umgebungsmodus (development oder production)
# ENVIRONMENT=development
# In Produktion sollte dies auf "production" gesetzt werden.
# Beeinflusst Sicherheitsvalidierungen beim App-Start.
# In Produktion werden Standardwerte für JWT_SECRET_KEY blockiert.

# Logging (optional)
# LOG_LEVEL=INFO
# LOG_JSON=false
# In Produktion oft LOG_JSON=true für zentrale Log-Aggregation (ELK, Datadog)
# SLOW_REQUEST_THRESHOLD_SECONDS=5.0
# Schwellwert in Sekunden: Requests darüber werden als langsam geloggt (WARNING)
# MAX_REQUEST_BODY_MB=10
# Maximale Request-Body-Größe in MB; bei Überschreitung 413. Leer = unbegrenzt.

# Pipeline-Discovery-Cache (optional)
# PIPELINE_CACHE_TTL_SECONDS=60
# TTL in Sekunden; nach Ablauf wird beim nächsten Aufruf neu gescannt. Git-Sync invalidiert sofort.

# Datenbank-Konfiguration
# DATABASE_URL=postgresql://user:password@host:5432/dbname
# Wenn nicht gesetzt: SQLite wird verwendet (./data/fastflow.db)

# Verzeichnis-Konfiguration
# PIPELINES_DIR=./pipelines
# LOGS_DIR=./logs
# DATA_DIR=./data
# PIPELINES_HOST_DIR wird automatisch aus PIPELINES_DIR gesetzt (nur manuell setzen wenn nötig)
# UV_CACHE_HOST_DIR wird automatisch aus UV_CACHE_DIR gesetzt (nur manuell setzen wenn nötig)

# Docker & UV-Konfiguration
# WORKER_BASE_IMAGE=ghcr.io/astral-sh/uv:python3.11-bookworm-slim
# Alternativ (nur uv, Python via Preheating): ghcr.io/astral-sh/uv:bookworm-slim
# oder: docker build -f Dockerfile.worker -t fastflow-worker:latest
# UV_CACHE_DIR=./data/uv_cache
# UV_PRE_HEAT=true
# UV_PYTHON_INSTALL_DIR=./data/uv_python
# UV_PYTHON_INSTALL_HOST_DIR=
# DEFAULT_PYTHON_VERSION=3.11

# Concurrency & Timeouts
# MAX_CONCURRENT_RUNS=10
# CONTAINER_TIMEOUT=
# RETRY_ATTEMPTS=0

# Git-Konfiguration
# GIT_BRANCH=main
# AUTO_SYNC_ENABLED=false
# AUTO_SYNC_INTERVAL=

# Log-Management
# LOG_RETENTION_RUNS=
# LOG_RETENTION_DAYS=
# LOG_MAX_SIZE_MB=
# LOG_STREAM_RATE_LIMIT=100

# Log-Backup (S3/MinIO): Pipeline-Logs vor lokaler Löschung nach S3/MinIO sichern
# S3_BACKUP_ENABLED=false
# S3_ENDPOINT_URL=http://minio:9000
# S3_BUCKET=fastflow-logs
# S3_ACCESS_KEY=minioadmin
# S3_SECRET_ACCESS_KEY=minioadmin
# S3_REGION=us-east-1
# S3_PREFIX=pipeline-logs
# S3_USE_PATH_STYLE=true

# Secrets-Verschlüsselung (MUSS gesetzt werden!)
# ENCRYPTION_KEY=your-fernet-key-here
# Generiere einen Key mit: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"

# Authentication-Konfiguration (Login nur via GitHub OAuth)
# JWT_SECRET_KEY=change-me-in-production
# ⚠️ WICHTIG: In Produktion muss JWT_SECRET_KEY auf einen sicheren, zufälligen Wert gesetzt werden (mind. 32 Zeichen)!
# JWT_ALGORITHM=HS256
# JWT_ACCESS_TOKEN_MINUTES=15
# JWT_EXPIRATION_HOURS=24

# CORS-Konfiguration (für Produktion)
# CORS_ORIGINS=https://yourdomain.com,https://app.yourdomain.com
# Standard in Development: localhost-Origins sind erlaubt
# In Produktion sollte dies auf die tatsächlichen Frontend-Origins gesetzt werden

# GitHub Apps Authentifizierung (optional)
# GITHUB_APP_ID=
# GITHUB_INSTALLATION_ID=
# GITHUB_PRIVATE_KEY_PATH=

# GitHub OAuth (User-Login, nicht GitHub App)
# Erstelle eine OAuth App: GitHub → Settings → Developer settings → OAuth Apps
# Authorization callback URL: {BASE_URL}/api/auth/github/callback
# GITHUB_CLIENT_ID=
# GITHUB_CLIENT_SECRET=
# INITIAL_ADMIN_EMAIL=deine-github-mail@beispiel.de

# Google OAuth (User-Login)
# OAuth-Client in Google Cloud Console: APIs & Services → Anmeldedaten → OAuth 2.0-Client-IDs
# Authorisierte Weiterleitungs-URIs: {BASE_URL}/api/auth/google/callback
# GOOGLE_CLIENT_ID=
# GOOGLE_CLIENT_SECRET=

# Microsoft OAuth (Entra ID / Azure AD, User-Login)
# App-Registrierung im Azure Portal; Redirect URI: {BASE_URL}/api/auth/microsoft/callback
# MICROSOFT_CLIENT_ID=
# MICROSOFT_CLIENT_SECRET=
# MICROSOFT_TENANT_ID=common

# Custom OAuth (Keycloak, Auth0, eigener IdP)
# Alle drei URLs + CLIENT_ID + CLIENT_SECRET müssen gesetzt sein.
# CUSTOM_OAUTH_CLIENT_ID=
# CUSTOM_OAUTH_CLIENT_SECRET=
# CUSTOM_OAUTH_AUTHORIZE_URL=
# CUSTOM_OAUTH_TOKEN_URL=
# CUSTOM_OAUTH_USERINFO_URL=
# CUSTOM_OAUTH_SCOPES=openid email profile
# CUSTOM_OAUTH_CLAIM_ID=sub
# CUSTOM_OAUTH_CLAIM_EMAIL=email
# CUSTOM_OAUTH_CLAIM_NAME=name
# CUSTOM_OAUTH_NAME=Custom

# OAuth-Startup: Mind. ein Provider (GitHub, Google, Microsoft oder Custom) mit CLIENT_ID+CLIENT_SECRET ist Pflicht.
# Beim Start werden die Credentials beim Anbieter verifiziert. Zum Überspringen (z.B. CI/Tests):
# SKIP_OAUTH_VERIFICATION=0


# E-Mail-Benachrichtigungen (optional)
# EMAIL_ENABLED=false
# SMTP_HOST=smtp.example.com
# SMTP_PORT=587
# SMTP_USER=user@example.com
# SMTP_PASSWORD=your-password
# SMTP_FROM=noreply@example.com
# EMAIL_RECIPIENTS=admin@example.com,team@example.com

# Microsoft Teams-Benachrichtigungen (optional)
# TEAMS_ENABLED=false
# TEAMS_WEBHOOK_URL=https://outlook.office.com/webhook/...

# Frontend-URL (optional, für Links in Benachrichtigungen)
# FRONTEND_URL=http://localhost:3000
# BASE_URL=http://localhost:8000
